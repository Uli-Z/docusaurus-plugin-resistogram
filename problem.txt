# Problem Summary: ResizeObserver Loop in React Component

## 1. High-Level Overview

The `ResistanceTable` React component displays a potentially large grid of data (~16x30 cells). It is designed to be responsive, switching between `full`, `compact`, and `superCompact` layouts based on the available container width. To detect width changes, it uses a `ResizeObserver`.

The core problem is a `ResizeObserver loop completed with undelivered notifications` error that occurs when the mouse is moved quickly over the table cells. This action triggers tooltips for each cell, which appears to cause a micro-layout shift, creating a feedback loop:

**Render -> Layout Shift -> ResizeObserver fires -> State Update -> Re-render -> Loop**

The goal is to have a performant tooltip system and a responsive layout without triggering this error.

---

## 2. Current Architecture

The component currently implements the **"Single Tooltip" pattern**, which is considered a best practice for performance.
- There is only one single `<RadixTooltip.Root>` instance for the entire table.
- When a cell is hovered, its content is passed to the global tooltip state.
- A "virtual trigger" element is moved to the location of the hovered cell, which Radix UI then uses to position the tooltip.
- This correctly prevents the performance cost of rendering hundreds of tooltip components.

---

## 3. The Challenge

The `ResizeObserver` is necessary for the responsive layout, but it is too sensitive. It detects the sub-pixel layout "jitter" caused by the browser re-rendering styles (e.g., hover highlights) or the tooltip appearing/disappearing via its portal.

The core question is: **How can we reliably detect legitimate container resize events (e.g., window resizing) without being triggered by the component's own rendering side-effects?**

---

## 4. Attempted and Failed Solutions

1.  **Debouncing (`requestAnimationFrame` & `setTimeout`):** Wrapping the `ResizeObserver`'s callback in these did not solve the issue, suggesting the feedback loop is more immediate than these timers can prevent.
2.  **Width Threshold:** A check was added to only update the layout if the width changed by more than a 5px threshold. This successfully stopped the loop, but it also **broke legitimate resizing**, as the component would get "stuck" in a layout until the window was resized by a large amount.
3.  **CSS `contain: strict`:** Applying this CSS property to the container successfully stopped the loop but **broke rendering entirely**, causing the table not to be displayed at all.
4.  **State-Aware Updates:** The current implementation uses a functional `setDisplay(prevMode => ...)` update to avoid a re-render if the calculated display mode is the same as the previous one. While this is a good practice, it has not been sufficient to stop the loop during rapid mouse movements.

---

## 5. Relevant Source Code

Here is the current state of the most relevant files.

### --- src/theme/ResistanceTable/index.tsx ---
*This is the main component. It contains the `ResizeObserver` logic and the state management for the single tooltip.*

```tsx
import { useColorMode } from '@docusaurus/theme-common';
import React, {
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
  useCallback,
} from 'react';
import * as RadixTooltip from '@radix-ui/react-tooltip';
import { useResistanceTableData } from './hooks/useResistanceTableData';
import { SourceSwitcher } from './ui/components';
import { TableHeader, TableBody, Legend } from './components';
import styles from './styles.module.css';

// A simple, non-interactive table used only for measuring its width
// to decide which display mode to use (full, compact, etc.).
const GhostTable = React.forwardRef<
  HTMLTableElement,
  {
    displayMode: 'full' | 'compact' | 'superCompact';
    cols: any[];
    data: any[];
    styles: any;
  }
>(({ displayMode, cols, data, styles }, ref) => (
  <table ref={ref} className={styles.resistanceTable}>
    <thead>
      <tr>
        <th></th>
        {cols.map((c) => (
          <th key={c.id}>
            {displayMode === 'full'
              ? c.name
              : displayMode === 'compact'
              ? c.short
              : 'X'}
          </th>
        ))}
      </tr>
    </thead>
    <tbody>
      {data.map((row) => (
        <tr key={row.rowLong}>
          <td>{displayMode === 'full' ? row.rowLong : row.rowShort}</td>
          {cols.map((c) => (
            <td key={c.id}>-</td>
          ))}
        </tr>
      ))}
    </tbody>
  </table>
));

// This is a virtual, invisible trigger for the single global tooltip.
// Radix UI will use this element's position to place the tooltip.
// We manually update its position to match the currently hovered cell.
const VirtualTrigger = React.forwardRef<HTMLSpanElement, {}>(function VirtualTrigger(props, ref) {
  return <span ref={ref} style={{ position: 'fixed', top: 0, left: 0, width: 0, height: 0 }} />;
});


export default function ResistanceTable({
  params: paramString,
  pageText: pageTextJson,
}: {
  params: string;
  pageText: string;
}) {
  const pageText = JSON.parse(pageTextJson) as string;
  const { colorMode } = useColorMode();

  // State for table interactivity and display
  const [showEmpty, setShowEmpty] = useState(false);
  const [display, setDisplay] = useState<'full' | 'compact' | 'superCompact'>('full');
  const [ready, setReady] = useState(false);
  const [hover, setHover] = useState<{ row: number | null; col: number | null }>({ row: null, col: null });
  const [selectedSource, setSelectedSource] = useState<any>(null);

  // State for the single, global tooltip
  const [tooltipContent, setTooltipContent] = useState<React.ReactNode>(null);
  const [tooltipOpen, setTooltipOpen] = useState(false);
  const virtualTriggerRef = useRef<HTMLSpanElement>(null);

  // Refs for width measurement
  const containerRef = useRef<HTMLDivElement>(null);
  const fullRef = useRef<HTMLTableElement>(null);
  const compactRef = useRef<HTMLTableElement>(null);
  const superRef = useRef<HTMLTableElement>(null);

  const {
    resistanceData,
    data,
    cols,
    rowsAreAbx,
    emptyRowIds,
    emptyColIds,
    sources,
    p,
  } = useResistanceTableData(paramString, pageText, selectedSource, showEmpty);

  // Effect to set the initial data source
  useEffect(() => {
    if (!selectedSource && sources.length) setSelectedSource(sources[0]);
  }, [sources, selectedSource]);

  // Effect to update visibility of empty rows/cols based on params
  useEffect(() => setShowEmpty(p.showEmpty === 'true'), [p.showEmpty]);

  // This function calculates the appropriate display mode based on container width.
  const getDisplayMode = useCallback(() => {
    const w = containerRef.current?.offsetWidth ?? 0;
    if (!w) return 'full';
    if (fullRef.current && fullRef.current.scrollWidth <= w) return 'full';
    if (compactRef.current && compactRef.current.scrollWidth <= w) return 'compact';
    return 'superCompact';
  }, []);

  useLayoutEffect(() => {
    if (fullRef.current && compactRef.current && superRef.current) {
      setDisplay(getDisplayMode());
      if (!ready) setReady(true);
    }
  }, [sources, ready, showEmpty, getDisplayMode]);

  // This effect sets up the ResizeObserver to handle dynamic table layouts.
  useEffect(() => {
    if (!ready || !containerRef.current) return;

    const observer = new ResizeObserver(() => {
      // We use a functional state update to get the most recent `prevMode`.
      // We only update the state if the new mode is different from the previous one.
      // This is the key to preventing the "ResizeObserver loop completed" error.
      setDisplay(prevMode => {
        const newMode = getDisplayMode();
        return newMode === prevMode ? prevMode : newMode;
      });
    });

    observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, [ready, getDisplayMode]);

  // Callbacks for the global tooltip
  const showTooltip = useCallback((content: React.ReactNode, element: HTMLElement) => {
    if (!virtualTriggerRef.current) return;
    const rect = element.getBoundingClientRect();
    virtualTriggerRef.current.style.left = `${rect.left + rect.width / 2}px`;
    virtualTriggerRef.current.style.top = `${rect.top}px`;
    setTooltipContent(content);
    setTooltipOpen(true);
  }, []);

  const hideTooltip = useCallback(() => {
    setTooltipOpen(false);
  }, []);

  // Callbacks for row/column highlighting
  const handleSetHover = useCallback((row: number, col: number) => setHover({ row, col }), []);
  const handleClearHover = useCallback(() => setHover({ row: null, col: null }), []);

  const renderHiddenInfo = () => {
    const hiddenRowCount = emptyRowIds.length;
    const hiddenColCount = emptyColIds.length;
    if (!hiddenRowCount && !hiddenColCount) return null;
    const rowLabel = rowsAreAbx ? 'antibiotic' : 'organism';
    const colLabel = rowsAreAbx ? 'organism' : 'antibiotic';
    const parts: string[] = [];
    if (hiddenRowCount) parts.push(`${hiddenRowCount} ${rowLabel}${hiddenRowCount > 1 ? 's' : ''}`);
    if (hiddenColCount) parts.push(`${hiddenColCount} ${colLabel}${hiddenColCount > 1 ? 's' : ''}`);
    return (
      <div>
        {parts.join(' and ')} {showEmpty ? 'with no data' : 'hidden'} (
        <a href="#" onClick={(e) => { e.preventDefault(); setShowEmpty(!showEmpty); }}>
          {showEmpty ? 'hide' : 'show'}
        </a>
        )
      </div>
    );
  };

  if (!sources) {
    return <div className={styles.error}>Error: plugin data not found.</div>;
  }

  return (
    <RadixTooltip.Provider>
      <div ref={containerRef}>
        {sources.length > 0 && selectedSource && (
          <SourceSwitcher
            sources={sources}
            selected={selectedSource}
            onSelect={setSelectedSource}
            styles={styles}
          />
        )}

        <div style={{ visibility: 'hidden', height: 0, overflow: 'hidden' }}>
          <GhostTable ref={fullRef} displayMode="full" cols={cols} data={data} styles={styles} />
          <GhostTable ref={compactRef} displayMode="compact" cols={cols} data={data} styles={styles} />
          <GhostTable ref={superRef} displayMode="superCompact" cols={cols} data={data} styles={styles} />
        </div>

        {!selectedSource ? (
          <div className={styles.error}>Loading data source…</div>
        ) : !resistanceData.length || !data.length ? (
          <div className={styles.noDataContainer}>
            <p><strong>Resistance Table</strong></p>
            <p>No matching resistance data found in this source.</p>
            <ul>
              <li>Antibiotics: {p.abx || 'all'}</li>
              <li>Organisms: {p.org || 'all'}</li>
            </ul>
          </div>
        ) : (
          ready && (
            <div className={styles.tableContainer}>
              <table className={styles.resistanceTable} style={{ borderCollapse: 'separate', borderSpacing: 0 }}>
                <TableHeader
                  cols={cols}
                  displayMode={display}
                  hoveredCol={hover.col}
                  onSetHover={handleSetHover}
                  onClearHover={handleClearHover}
                  styles={styles}
                />
                <TableBody
                  data={data}
                  cols={cols}
                  displayMode={display}
                  rowsAreAbx={rowsAreAbx}
                  hoveredRow={hover.row}
                  hoveredCol={hover.col}
                  onSetHover={handleSetHover}
                  onClearHover={handleClearHover}
                  onShowTooltip={showTooltip}
                  onHideTooltip={hideTooltip}
                  styles={styles}
                  colorMode={colorMode}
                />
              </table>
              <Legend cols={cols} displayMode={display} styles={styles} />
              <div className={styles.sourceInfo}>
                {renderHiddenInfo()}
                Source:{' '}
                <a href={selectedSource.url} target="_blank" rel="noopener noreferrer">
                  {selectedSource.long_name}
                </a>
              </div>
            </div>
          )
        )}
      </div>

      {/* This is the single, global tooltip that provides high performance. */}
      <RadixTooltip.Root open={tooltipOpen} onOpenChange={setTooltipOpen}>
        <RadixTooltip.Trigger asChild><VirtualTrigger ref={virtualTriggerRef} /></RadixTooltip.Trigger>
        <RadixTooltip.Portal>
          <RadixTooltip.Content side="top" align="center" sideOffset={5} className={styles.tooltipContent}>
            {tooltipContent}
            <RadixTooltip.Arrow width={8} height={4} className={styles.tooltipArrow} />
          </RadixTooltip.Content>
        </RadixTooltip.Portal>
      </RadixTooltip.Root>
    </RadixTooltip.Provider>
  );
}
```

### --- src/theme/ResistanceTable/components/TableCell.tsx ---
*This is the cell component where the user interaction originates.*

```tsx
import React from 'react';
import { CellTooltipContent } from '../ui/components';
import { cellStyle, hl } from '../utils';

// Mock types will be replaced with proper types later
type FormattedCell = { text: string; pct?: number };
type FormattedRow = Record<string, any> & { rowLong: string; rowShort: string };
type FormattedCol = { id: string; name: string; short: string };

interface TableCellProps {
  row: FormattedRow;
  col: FormattedCol;
  rowsAreAbx: boolean;
  rowIndex: number;
  colIndex: number;
  hoveredRow: number | null;
  hoveredCol: number | null;
  onSetHover: (row: number, col: number) => void;
  onClearHover: () => void;
  onShowTooltip: (content: React.ReactNode, element: HTMLElement) => void;
  onHideTooltip: () => void;
  styles: any;
  colorMode: 'dark' | 'light';
}

export const TableCell = React.memo(
  ({
    row,
    col,
    rowsAreAbx,
    rowIndex,
    colIndex,
    hoveredRow,
    hoveredCol,
    onSetHover,
    onClearHover,
    onShowTooltip,
    onHideTooltip,
    styles,
    colorMode,
  }: TableCellProps) => {
    const cell = row[col.name] as FormattedCell;
    const highlight = hoveredRow === rowIndex || hoveredCol === colIndex;

    // This handler is called when the mouse enters the cell.
    // It is responsible for two things:
    // 1. Setting the hover state for row/column highlighting.
    // 2. Showing the tooltip by passing its content and the target element
    //    to the parent component.
    const handleMouseEnter = (event: React.MouseEvent<HTMLTableCellElement>) => {
      onSetHover(rowIndex, colIndex);
      const content = (
        <CellTooltipContent
          row={row}
          col={col}
          cell={cell}
          rowsAreAbx={rowsAreAbx}
        />
      );
      onShowTooltip(content, event.currentTarget);
    };

    // This handler is called when the mouse leaves the cell.
    const handleMouseLeave = () => {
      onClearHover();
      onHideTooltip();
    };

    return (
      <td
        style={{
          ...cellStyle(cell?.pct, colorMode),
          ...(highlight ? hl : {}),
        }}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
      >
        <span className={styles.fullCellTrigger}>
          {cell ? cell.text : '—'}
        </span>
      </td>
    );
  },
);
```

### --- src/theme/ResistanceTable/styles.module.css ---
*The relevant CSS file.*

```css
/* ============================================================================
   General Styles
   ============================================================================ */

:root {
  --rt-border-color: #ddd;
  --rt-background-color: #fff;
  --rt-text-color: #333;
  --rt-subtle-background: #f9f9f9;
  --rt-subtle-background-hover: #f0f0f0;
  --rt-source-info-background: #f0f0f0;
  --rt-source-info-text: #666;
  --rt-empty-cell-background: #f2f2f2;
  --rt-tooltip-background: rgba(60, 60, 60, 0.9);
  --rt-tooltip-text: #fff;
}

[data-theme='dark'] {
  --rt-border-color: #444;
  --rt-background-color: #1e1e1e;
  --rt-text-color: #eee;
  --rt-subtle-background: #252525;
  --rt-subtle-background-hover: #333;
  --rt-source-info-background: #333;
  --rt-source-info-text: #bbb;
  --rt-empty-cell-background: #2a2a2a;
  --rt-tooltip-background: rgba(200, 200, 200, 0.9);
  --rt-tooltip-text: #000;
}

.error {
  color: red;
  border: 1px solid red;
  padding: 1rem;
}

/* ============================================================================
   Resistance Table
   ============================================================================ */

.resistanceTable {
  width: 100%;
  overflow-x: auto;
  border-collapse: separate;
  border-spacing: 0;
  margin-bottom: 0;
}

.tableContainer {
  display: inline-block;
}

.resistanceTable th,
.resistanceTable td {
  padding: 0.5rem;
  text-align: left;
  border-bottom: 1px solid var(--rt-border-color);
  color: var(--rt-text-color);
}

/* ============================================================================
   Source Switcher
   ============================================================================ */

.sourceSwitcherDisplay {
  margin-bottom: 1rem;
  font-style: italic;
}

.sourceSwitcherTrigger {
  background-color: var(--rt-subtle-background-hover);
  border: 1px solid var(--rt-border-color);
  color: var(--rt-text-color);
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 1rem;
}

.sourceSwitcherTriggerInner {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sourceSwitcherChevron {
  width: 16px;
  height: 16px;
}

.sourceSwitcherContent {
  background-color: var(--rt-background-color);
  border: 1px solid var(--rt-border-color);
  border-radius: 4px;
  padding: 0.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  z-index: 10;
}

.sourceSwitcherItem {
  padding: 0.5rem 1rem;
  cursor: pointer;
  color: var(--rt-text-color);
}

.sourceSwitcherItem:hover {
  background-color: var(--rt-subtle-background-hover);
}

/* ============================================================================
   Tooltip
   ============================================================================ */

.tooltipContent {
  background-color: var(--rt-tooltip-background);
  color: var(--rt-tooltip-text);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  white-space: nowrap;
  z-index: 100;
}

.tooltipArrow {
  fill: var(--rt-tooltip-background);
}

/* ============================================================================
   Legend
   ============================================================================ */

.legend {
  background-color: var(--rt-subtle-background);
  border: 1px solid var(--rt-border-color);
  border-top: none;
  padding: 0.75rem;
  font-size: 0.9rem;
  color: var(--rt-text-color);
}

.legend b {
  font-weight: 600;
}

.sourceInfo {
  background-color: var(--rt-source-info-background);
  border: 1px solid var(--rt-border-color);
  border-top: none;
  padding: 0.25rem 0.75rem;
  font-size: 0.65rem;
  color: var(--rt-source-info-text);
}

.sourceInfo a {
  color: var(--rt-source-info-text);
  text-decoration: none;
}

.sourceInfo a:hover {
  text-decoration: underline;
}

/* ============================================================================
   No Data Box
   ============================================================================ */

.noDataContainer {
  border: 1px solid var(--rt-border-color);
  border-bottom: none; /* The sourceInfo will have the bottom border */
  padding: 1rem;
  background-color: var(--rt-subtle-background); /* A light background */
  color: var(--rt-text-color);
}

.noDataContainer p {
  margin-top: 0;
  margin-bottom: 0.5rem;
}

.noDataContainer ul {
  margin-bottom: 0;
  padding-left: 1.5rem;
}

.fullCellTrigger {
  display: block;
  margin: -0.5rem; /* Counteract the cell's default padding */
  padding: 0.5rem; /* Add the padding back to the content */
}
```
